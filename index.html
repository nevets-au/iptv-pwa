<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <link rel="manifest" href="manifest.json">
  <title>IPTV PWA (Cleaned)</title>
  <!-- hls.js moved inside <head> where it belongs -->
  <script src="https://cdn.jsdelivr.net/npm/hls.js@1.4.0/dist/hls.min.js"></script>
  <style>
    body{font-family: -apple-system, system-ui, Roboto, Arial; margin:0; padding:0; display:flex; flex-direction:column; height:100vh;}
    header{padding:12px; background:#111; color:#fff;}
    main{display:flex; gap:12px; padding:12px; flex:1; overflow:hidden}
    #channels{width:320px; overflow:auto; border-right:1px solid #ddd; padding-right:8px;}
    .chan{padding:8px; border-bottom:1px solid #eee; cursor:pointer;}
    .chan:hover{background:#f3f3f3}
    #playerWrap{flex:1; display:flex; flex-direction:column;}
    video{width:100%; height:60vh; background:#000;}
    #epg{flex:1; overflow:auto; margin-top:8px}
    .logo{height:28px; width:28px; object-fit:contain; margin-right:8px; vertical-align:middle}
  </style>
</head>
<body>
  <header><strong>IPTV PWA</strong> — Tap channel, then use AirPlay from Safari</header>
  <main>
    <section id="channels"><em>Loading channels…</em></section>
    <section id="playerWrap">
      <video id="player" controls playsinline webkit-playsinline x-webkit-airplay="allow"></video>
      <div style="padding:8px"> <button id="airplayBtn">Show AirPlay Targets</button> </div>
      <div id="epg"></div>
    </section>
  </main>

<script>
/* Always fetch fresh playlist — service worker is configured to bypass cache for /playlist/ */
const CLEANED_PLAYLIST_URL = "playlist/index.m3u?v=" + Date.now();

async function fetchText(url){ const r=await fetch(url, {cache: "no-store"}); if(!r.ok) throw new Error(r.statusText); return r.text(); }

function parseM3U(text){
  const lines = text.split(/\r?\n/);
  const channels = [];
  for(let i=0;i<lines.length;i++){
    const l = lines[i].trim();
    if(!l) continue;
    if(l.startsWith("#EXTINF")){
      const meta = l;
      const name = meta.split(",").slice(1).join(",").trim();
      const tvgLogo = (meta.match(/tvg-logo="([^"]+)"/) || [null,null])[1] || "";
      const tvgId = (meta.match(/tvg-id="([^"]+)"/) || [null,null])[1] || "";
      const url = (lines[i+1]||"").trim();
      channels.push({name, tvgLogo, tvgId, url});
    }
  }
  return channels;
}

function renderChannels(channels){
  const el = document.getElementById('channels'); el.innerHTML = "";
  if(channels.length === 0){
    el.innerHTML = "<em>Playlist is empty — the GitHub Action may not have run yet.</em>";
    return;
  }
  channels.forEach((c)=>{
    const div=document.createElement('div'); div.className='chan';
    div.innerHTML = `<img class="logo" src="${c.tvgLogo||''}" onerror="this.style.display='none'">${c.name} <div style="font-size:12px;color:#666">${c.tvgId||''}</div>`;
    div.onclick = ()=>playChannel(c);
    el.appendChild(div);
  });
}

function playChannel(c){
  const player = document.getElementById('player');
  // If browser supports native HLS (Safari), use src directly
  if(player.canPlayType('application/vnd.apple.mpegurl')) {
    player.src = c.url;
    player.play().catch(e=>console.warn("Play failed:",e));
    return;
  }
  // Otherwise use hls.js
  if (window.Hls && Hls.isSupported()) {
    if (window._hls) { window._hls.destroy(); window._hls = null; }
    const hls = new Hls();
    window._hls = hls;
    hls.loadSource(c.url);
    hls.attachMedia(player);
    hls.on(Hls.Events.MANIFEST_PARSED, function() { player.play().catch(e=>console.warn(e)); });
    hls.on(Hls.Events.ERROR, function(event, data) {
      console.warn("HLS error", data);
    });
    return;
  }
  // Fallback: attempt direct assign
  player.src = c.url;
  player.play().catch(e=>console.warn("Play failed:",e));
}

document.getElementById('airplayBtn').addEventListener('click', ()=>{
  const player = document.getElementById('player');
  if(player.webkitShowPlaybackTargetPicker) try{ player.webkitShowPlaybackTargetPicker(); } catch(e){ alert('AirPlay picker not available: ' + e.message); }
  else alert('AirPlay picker not supported in this browser — use native control center.');
});

async function init(){
  try{
    const m3u = await fetchText(CLEANED_PLAYLIST_URL);
    const list = parseM3U(m3u);
    renderChannels(list);
  }catch(err){
    document.getElementById('channels').innerText = "Failed to load playlist: " + err.message;
  }
}

// Register service worker and force it to update immediately
if('serviceWorker' in navigator){
  navigator.serviceWorker.register('service-worker.js').then(reg => {
    reg.update(); // check for a new SW version on every page load
  }).catch(e=>console.warn(e));
}

init();
</script>
</body>
</html>
